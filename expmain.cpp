/*******************************************************************************main.cppC++ main for the performance calculations of volumetric turbine Copyright © 2000 LENI-DGM-EPFL.  All rights reserved.$Id: Expander.cpp,v 1.0 2000/03/14 17:10:00 Malick Kane Exp $*******************************************************************************//*test*/#include <iostream>#include "BasicEnergySystem/turbine/expander.h"   //classe de turbine//#include "Thermotype.h" //fluide de travail#include"fluids/LeeKessler.h"#include "BasicEnergySystem/BasicES.h"#include "iofile/iofile.h"#include "gao/gao.h"using namespace std;float objectif  (TSequence& vect);float puissance (TSequence& s);float puissance2 (GAGenome& g);void InitError (void){};int main() {		//Initialisation du fluide de travail    LeeKessler* htFluid=new LeeKessler("R134a");    cout<<"init"<<endl;//Initialisation des erreurs	InitError();	//Performance d'un expander   TExpander Expander(htFluid,TExpander::TRANE,TTurbine::VARIABLE);    gao ga ("expdata.txt","mxrslts.txt");	Expander.optimizer(ga);   Expander.init(); //   cout<<*Expander.flow->Massflow<<endl;//    Expander.display();   cout<<"------------------------------------------"<<endl<<endl;    Expander.performance();    Expander.optimize(TTurbine::POWER);    //ga.maximize(Expander, gao::simple);    Expander.display();//    cout<<"------------------------------------------"<<endl<<endl;//operateur genetique et optimisation de la turbine/*	mxgao mxga ("mxdata.txt", "mxxxrslts.txt");	Expander.optimizer(mxga);    Expander.init();	Expander.optimize (TTurbine::POWER, gao::simple);	Expander.display();*///Changement de fluid et de fichier des resultats puis optimsation;/*    mxgao mxga ("mxdata.txt", "mxrslts.txt");	Expander.optimizer(mxga);	mxga.resultfile ("expmxrslts1.txt");	Expander.optimize(TTurbine::POWER, gao::simple);	Expander.display();*///Optimisation d'un nouveau expander		return 0;}float objectif  (TSequence& vect){   TExpander Epder;   Epder.speed (TTurbine::FIXED);   Epder.type  (TExpander::TRANE);      return (float)Epder.efficiency(vect);} /*float value=0.0;   for(int i=0; i<vect.size(); i++)     value += vect.Get(i);   return vect.Value=value;*/float puissance (TSequence& s){       float Pin, Tin, Xin, Pout, Mflow, Nrot;       double val = 0.0;              Pin 	= 	s.Get(0)  ;       Tin 	= 	s.Get(1)  ;       Xin 	= 	s.Get(2)  ;       Pout 	= 	s.Get(3) ;       Mflow 	= 	s.Get(4);       Nrot 	=	s.Get(5) ;             // InitMacroExpanderLib();       // InitExpanderData(pdata, Pin,Tin, Xin, Pout, Mflow, Nrot);       //MacroExpanderM(pdata);       //val = EtaG*100;       return (float) val; }      float puissance2 (GAGenome& g){       float Pin, Tin, Xin, Pout, Mflow, Nrot;       GARealGenome & chrom = (GARealGenome &) g;              double val = 0.0;             Pin 	= 	chrom.gene(0)  ;       Tin 	= 	chrom.gene(1)  ;       Xin 	= 	chrom.gene(2)  ;       Pout 	= 	chrom.gene(3)  ;       Mflow 	= 	chrom.gene(4)  ;       Nrot 	=	50  ;             // InitMacroExpanderLib();       //InitExpanderData(pdata, Pin,Tin, Xin, Pout, Mflow, Nrot);       //MacroExpanderM(pdata);     //   val = pdata->ElecPower;       return (float) val;}