//FluidCore.cpp// TODO include maxiter criterium in algorithms#include "FluidCore.h"#include <iostream>#include <cstdlib>#include <cmath>//#include "../math/maths.h"#include "MWater.h"#include "PengRobinson.h"#include "LeeKessler.h"#include <unordered_set>using namespace std;//--------------------------------------------------------double Mfraction(const double &al,                 const double &ag,                 const double &a){    return (a-al)/(ag-al);}//------------------------------------------doubleFluidCore::sv_vT(	const double &v,                     const double &T){	double dPdv,dPdT;    dPvdPT_vT(v,T,dPdv,dPdT);    double cv,cp;    CvCp_vT(v,T,cv,cp);    // cout<<dPdv<<endl;    // cout<<v*sqrt(T*sqr(dPdT)/cv-dPdv)<<endl;    // return  v*sqrt(T*sqr(dPdT)/cv-dPdv);    return  v*sqrt(-cp/cv*dPdv);}//--------------------------------------------------------#pragma mark		=== COMMON FUNCTIONS ===//--------------------------------------------------------double //CALCUL DE P EN DONNANT V ET T DANS TOUTE LES ZONES (_a)FluidCore::P_vT_a(const double &v,                  const double &T){	if (T<Tc)    {	double Ps = P_T_s(T);        double vl,vg;        v_PT(Ps,T,vl,vg);        if ((vl<v)&&(v<vg)) return Ps;    }    return P_vT(v,T);}//------------------------------------------doubleFluidCore::u_vT_a(const double &v,                  const double &T){	if (T<Tc)    {	double Ps = P_T_s(T);        double vl,vg,a_T;        v_PT(Ps,T,vl,vg);        if ((vl<v)&&(v<vg))        {	double x = Mfraction(vl,vg,v);            double ul = u_vT(vl,T);            double ug = u_vT(vg,T);            return ul + x*(ug-ul);        }    }    return u_vT(v,T);}//------------------------------------------doubleFluidCore::h_vT_a(const double &v,                  const double &T){	if (T<Tc)    {	double Ps = P_T_s(T);        double vl,vg;        v_PT(Ps,T,vl,vg);        if ((vl<v)&&(v<vg))        {	double x = Mfraction(vl,vg,v);            double hl = h_vT(vl,T);            double hg = h_vT(vg,T);            return hl + x*(hg-hl);        }    }    return h_vT(v,T);}//------------------------------------------doubleFluidCore::s_vT_a(const double &v,                  const double &T){	if (T<Tc)    {	double Ps = P_T_s(T);        double vl,vg;        v_PT(Ps,T,vl,vg);        if ((vl<v)&&(v<vg))        {	double x = Mfraction(vl,vg,v);            double sl = s_vT(vl,T);            double sg = s_vT(vg,T);            return sl + x*(sg-sl);        }    }    return s_vT(v,T);}//------------------------------------------void //CALCUL DE LA PROPORTION x DU FLUIDE EN LUI DONNANT VOLUME ET TEMPERATURE UNIQUEMENTFluidCore::Prop_vT_a(	const double &v,                         const double &T,                         double &P,                         double &u,                         double &h,                         double &s,                         double &x){	if (T<Tc)    {        double v1,vl,vg,ul,ug,hl,hg,sl,sg;        Prop_T_s(T,vl,vg,P,ul,ug,hl,hg,sl,sg);        if ((vl<v)&&(v<vg))        {	x = Mfraction(vl,vg,v);            Prop_Tx_s(T,x,v1,P,u,h,s);        }else if (vl>v) {            x = -1;            P=P_vT(v,T);            u=u_vT(v,T);            h=h_vT(v,T);            s=s_vT(v,T);        }else {            x = -1;            P=P_vT(v,T);            u=u_vT(v,T);            h=h_vT(v,T);            s=s_vT(v,T);        }    }    else        cerr << "T >= Tc" << endl;}//------------------------------------------double FluidCore::T_vP_a(const double &v,                         const double &P){	if (P<Pc)    {	double Ts = T_P_s(P);        double vl,vg;        v_PT(P,Ts,vl,vg);        if ((vl<v)&&(v<vg))            return Ts;    }    return T_vP(v,P);}//------------------------------------------doubleFluidCore::h_vP_a(const double &v,                  const double &P){	if (P<Pc)    {	double Ts = T_P_s(P);        double vl,vg,a_T;        v_PT(P,Ts,vl,vg);        if ((vl<v)&&(v<vg))        {	// biphasic            double x = Mfraction(vl,vg,v);            double hl = h_vPT(vl,P,Ts);            double hg = h_vPT(vg,P,Ts);            return hl + x*(hg-hl);        }    }    double T = T_vP(v,P);    return h_vPT(v,P,T);}//------------------------------------------doubleFluidCore::h_PT_a(const double &P,                  const double &T){	double v,vl,vg;    v_PT(P,T,vl,vg);    v = vl;    if (P<Pc)    {	double Ts = T_P_s(P);        if (T>Ts)		v = vg; // gas zone        else if (T<Ts)	v = vl; // liq zone        else if (T==Ts) v = vg; // biphasic (h not def with P & T)    }    return h_vPT(v,P,T);}//------------------------------------------doubleFluidCore::T_vu(	const double &v,                    const double &u){	double To,fo,dT;    // secant method:    // init point    double T = Tc;    double f = u_vT(v,T)-u;    // init delta    if (f>0.0)	dT = 0.2;    else		dT = -0.2;    do    {	// previous point record        fo = f;        To = T;        // next point calculation        T -= dT;        f = u_vT(v,T)-u;        // new delta        dT = (T-To)/(f-fo)*f;    } while (abs(dT)> T_precision/1000.0);    T -= dT;    return T;}//------------------------------------------doubleFluidCore::T_vh(	const double &v,                    const double &h){	cout << " T_vh check v :" << v << endl;    cout << " T_vh check h :" << h << endl;    double To,fo;    // secant method:    // init point    double T = 0.7*Tc;    double f = h_vT_a(v,T)-h;    // init delta    double dT = 1.0;    do    {	// previous point record        fo = f;        To = T;        // next point calculation        T -= dT;        f = h_vT_a(v,T)-h;        // new delta        dT = (T-To)/(f-fo)*f;    } while (abs(dT)> T_precision);    T -= dT;    return T;}//------------------------------------------doubleFluidCore::P_vh(	const double &v,                    const double &h){	return P_vT_a(v,T_vh(v,h));}//------------------------------------------doubleFluidCore::T_vs(	const double &v,                    const double &s){	double To,fo;    // secant method:    // init point    double T = Tc;    double f = s_vT(v,T)-s;    // init delta    double dT = 0.1;    do    {	// previous point record        fo = f;        To = T;        // next point calculation        T -= dT;        f = s_vT(v,T)-s;        // new delta        dT = (T-To)/(f-fo)*f;    } while (abs(dT)> T_precision);    T -= dT;    return T;}//------------------------------------------doubleFluidCore::P_vs(	const double &v,                    const double &s){	return P_vT_a(v,T_vs(v,s));}//------------------------------------------doubleFluidCore::v_Ph_a(  const double &P,                    const double &h){	double dv,v,f,T;    // secant method:    // init point    if (P<Pc)    {	T = T_P_s(P);        double vl,vg;        v_PT(P,T,vl,vg);        double hl = h_vPT(vl,P,T);        double hg = h_vPT(vg,P,T);        if ((hl < h)&&(h<hg))        {	// biphasic            double x = Mfraction(hl,hg,h);            return vl + x*(vg-vl);        }        else if (hl > h)        {	// liquid phase            v = vl;            f = hl-h;            dv = 0.0001;        }        else if (hg < h)        {	// gas phase            v = vg;            f = hl-h;            dv = -0.001;        }    }    else    {	// surcritic zone        v = vc;        f = hc-h;        dv = -0.001;    }    double vo,fo;    do    {	// previous point record        fo = f;        vo = v;        // next point calculation        v -= dv;        T = T_vP(v,P);        f =  h_vPT(v,P,T)-h;        // new delta        dv = (v-vo)/(f-fo)*f;    } while (abs(dv)> v_precision);    v -= dv;    return v;}//------------------------------------------doubleFluidCore::s_Ph_a(const double &P,                  const double &h){	double v = v_Ph_a(P,h);    double T = T_vP_a(v,P);    return s_vT_a(v,T);}//------------------------------------------doubleFluidCore::v_Th_a(const double &T,                  const double &h){	double dv,v,f,P;    // secant method:    // init point    if (T<Tc)    {	P = P_T_s(T);        double vl,vg;        v_PT(P,T,vl,vg);        double hl = h_vPT(vl,P,T);        double hg = h_vPT(vg,P,T);        if ((hl < h)&&(h<hg))        {	// biphasic            double x = Mfraction(hl,hg,h);            return vl + x*(vg-vl);        }        else if (hl >= h)        {	// liquid phase            v = vl;            f = hl-h;            dv = 0.0001;        }        else        {	// gas phase            v = vg;            f = hl-h;            dv = -0.001;        }    }    else    {	// surcritic zone        v = vc;        f = hc-h;        dv = -0.001;    }    double vo,fo;    do    {	// previous point record        fo = f;        vo = v;        // next point calculation        v -= dv;        f =  h_vT(v,T)-h;        // new delta        dv = (v-vo)/(f-fo)*f;    } while (abs(dv)> v_precision);    v -= dv;    return v;}//------------------------------------------doubleFluidCore::v_Ts_a(const double &T,                  const double &s){	double dv,v,f,P;    // secant method:    // init point    if (T<Tc)    {	P = P_T_s(T);        double vl,vg;        v_PT(P,T,vl,vg);        double sl = s_vT(vl,T);        double sg = s_vT(vg,T);        if ((sl < s)&&(s<sg))        {	// biphasic            double x = Mfraction(sl,sg,s);            return vl + x*(vg-vl);        }        else if (sl > s)        {	// liquid phase            v = vl;            f = sl-s;            dv = 0.0001;        }        else if (sg < s)        {	// gas phase            v = vg;            f = sl-s;            dv = -0.001;        }    }    else    {	// surcritic zone        v = vc;        f = sc-s;        dv = -0.001;    }    double vo,fo;    do    {	// previous point record        fo = f;        vo = v;        // next point calculation        v -= dv;        f =  s_vT(v,T)-s;        // new delta        dv = (v-vo)/(f-fo)*f;    } while (abs(dv)> v_precision);    v -= dv;    return v;}//------------------------------------------doubleFluidCore::P_Ts_a(const double &T,                  const double &s){	return P_vT_a(v_Ts_a(T,s),T);}//------------------------------------------doubleFluidCore::P_Th_a(const double &T,                  const double &h){	return P_vT_a(v_Th_a(T,h),T);}//------------------------------------------doubleFluidCore::T_Ps_a(const double &P,                  const double &s){    double dT,f,T,a_T;    // secant method:    // init point    if (P<Pc)    {	T = T_P_s(P);        double vl,vg;        v_PT(P,T,vl,vg);        double sl = s_vT(vl,T);        double sg = s_vT(vg,T);        if ((sl < s)&&(s<sg))        {	// biphasic            return T;        }        else if (sl > s)        {	// liquid phase            return T_Ps_l(P,s);        }        else if (sg < s)        {	// gas phase            f = sg-s;            dT = -0.001;        }    }    else    {	if (s<sc)        {	// liquid surcritic zone            return T_Ps_l(P,s);        }        else        {	// gas surcritic zone            T = Tc;            f = sc-s;            dT = -0.01;        }    }    double To,fo,vl,vg;    do    {	// previous point record        fo = f;        To = T;        // next point calculation        T -= dT;        v_PT(P,T,vl,vg);        f =  s_vT(vg,T)-s;        // new delta        dT = (T-To)/(f-fo)*f;    } while (abs(dT)> T_precision);    T -= dT;    return T;};//------------------------------------------double FluidCore::v_Ps(const double &P,const double &s){    return v_Ps_a(P,s);}double FluidCore::v_Ps_a(const double &P,const double &s){    double dv,v,f,T;    // secant method:    // init point    if (P<Pc)    {	T = T_P_s(P);        double vl,vg;        v_PT(P,T,vl,vg);        double sl = s_vT(vl,T);        double sg = s_vT(vg,T);        if ((sl < s)&&(s<sg))        {	// biphasic            double x = Mfraction(sl,sg,s);            return vl + x*(vg-vl);        }        else if (sl > s)        {	// liquid phase            return v_Ps_l(P,s);        }        else if (sg < s)        {	// gas phase            v = vg;            f = sg-s;            dv = -0.001;        }    }    else    {	if (s<sc)        {	// liquid surcritic zone            return v_Ps_l(P,s);        }        else        {	// gas surcritic zone            v = vc;            f = sc-s;            dv = -0.0001;        }    }    double vo,fo;    do    {	// previous point record        fo = f;        vo = v;        // next point calculation        v -= dv;        T = T_vP(v,P);        f =  s_vT(v,T)-s;        // new delta        dv = (v-vo)/(f-fo)*f;    } while (abs(dv)> v_precision);    v -= dv;    return v;};//------------------------------------------doubleFluidCore::h_Ps(	const double &P,                    const double &s){	return h_vP_a(v_Ps_a(P,s),P);}//------------------------------------------doubleFluidCore::T_hs_a(const double &h,                  const double &s){	double v,P,Po,T;    // init point    P = Pc*0.7;    do    {	Po = P;        v = v_Ph_a(P,h);        T = T_vP_a(v,P); // f(x) ?????        P = P_Ts_a(T,s);        /*v = v_Ps_a(P,s);        P = P_vh(v,h);*/    }  while (abs(Po-P)> P_precision);    return T_vP_a(v,P);}//--------------------------------------------------------#pragma mark		=== VAPOR ZONE FUNCTIONS ===//--------------------------------------------------------doubleFluidCore::P_vT_g(const double &v,                  const double &T){	return P_vT_a(v,T);}//------------------------------------------voidFluidCore::CvCp_vT_g(	const double &v,                         const double &T,                         double &cv,                         double &cp){	CvCp_vT(v,T,cv,cp);}//------------------------------------------doubleFluidCore::v_PT_g(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return vg;}//------------------------------------------doubleFluidCore::u_PT_g(const double &P,                  const double &T){	double vl,vg,a_T;    v_PT(P,T,vl,vg);    return u_vT(vg,T);}//------------------------------------------doubleFluidCore::h_PT_g(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return h_vPT(vg,P,T);}//------------------------------------------doubleFluidCore::s_PT_g(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return s_vT(vg,T);}//------------------------------------------voidFluidCore::Prop_PT_g(const double &P,                     const double &T,                     double &v,                     double &u,                     double &h,                     double &s){	double P1;    v = v_PT_g(P,T);    Prop_vT(v,T,P1,u,h,s);}void    FluidCore::Prop_Ph_g(const double &P,const double &h,double &T,double &v,double &u,double &s){    double ptemp,htemp,x;    v=v_Ph_g(P,h);    T=T_vP(v,P);    Prop_vT_a(v,T,ptemp,u,htemp,s,x);}//------------------------------------------doubleFluidCore::v_Ph_g(const double &P,                  const double &h){	return v_Ph_a(P,h);}//------------------------------------------doubleFluidCore::T_vP_g(const double &v,                  const double &P){	return T_vP_a(v,P);}//------------------------------------------voidFluidCore::Prop_vu_g(	const double &v,                         const double &u,                         double &P,                         double &T,                         double &h,                         double &s){	double u1;    T = T_vu(v,u);    Prop_vT(v,T,P,u1,h,s);}//------------------------------------------doubleFluidCore::T_hs_g(const double &h,                  const double &s){	double v,P,T,Po;    // init point    P = Pc*0.5;    do    {	Po = P;        v = v_Ph_a(P,h);        T = T_vP_a(v,P);        P = P_Ts_a(T,s);    }  while (abs(Po-P)> P_precision);    return T;}//------------------------------------------//eq. (10-5.9)doubleFluidCore::B (int i){	switch (i)    {	case 1: return 2.4166E0   + 7.4824E-1 * w - 9.1858E-1 * sqr(sqr(Mur)) + 1.2172E2 * k;        case 2: return -5.0924E-1 - 1.5094E0  * w - 4.9991E1  * sqr(sqr(Mur)) + 6.9983E1 * k;        case 3: return 6.6107E0   + 5.6207E0  * w + 6.4760E1  * sqr(sqr(Mur)) + 2.7039E1 * k;        case 4: return 1.4543E1   - 8.9139E0  * w - 5.6379E0  * sqr(sqr(Mur)) + 7.4344E1 * k;        case 5: return 7.9274E-1  + 8.2019E-1 * w - 6.9369E-1 * sqr(sqr(Mur)) + 6.3173E0 * k;        case 6: return -5.8634E0  + 1.2801E1  * w + 9.5893E0  * sqr(sqr(Mur)) + 6.5529E1 * k;        case 7: return 9.1089E1   + 1.2811E2  * w - 5.4217E1  * sqr(sqr(Mur)) + 5.2381E2 * k;    }}//------------------------------------------//table 9.5doubleFluidCore::E (int i){	switch (i)    {	cout << "je demande le E(i) :" << i << endl;        case 1: return 6.324   + 50.412   * w - 51.68    * sqr(sqr(Mur)) + 1189  * k;        case 2: return 1.21E-3 - 1.154E-3 * w - 6.257E-3 * sqr(sqr(Mur)) + 0.03728 * k;        case 3: return 5.283   + 254.209  * w - 168.48   * sqr(sqr(Mur)) + 3898  * k;        case 4: return 6.623   + 38.096   * w - 8.464    * sqr(sqr(Mur)) + 31.42 * k;        case 5: return 19.745  + 7.63     * w - 14.354   * sqr(sqr(Mur)) + 31.53 * k;        case 6: return  -1.9   - 12.537   * w + 4.985    * sqr(sqr(Mur)) - 18.15 * k;        case 7: return 24.275  + 3.45     * w - 11.291   * sqr(sqr(Mur)) + 69.35 * k;        case 8: return 0.7972  + 1.117    * w + 0.01235  * sqr(sqr(Mur)) - 4.117 * k;        case 9: return -0.2382 + 0.0677   * w - 0.8163   * sqr(sqr(Mur)) + 4.025 * k;        case 10:return 0.006863+ 0.3479   * w + 0.5926   * sqr(sqr(Mur)) - 0.727 * k;    }}//-------------------------------------------------//ViscDyn in [Pa s],ViscCin in [m2/s],ThermCond in [W/(m K)]//from "The properties of gases and liquids" of Reid & Prausnitz, Chap. 9.4,9.6,10.5void FluidCore::TransProp_PTx(const double &P,                              const double &T,                              const double &x,                              double &ViscDyn,                              double &ViscCin,                              double &Ro,                              double &ThermCond,                              double &Prandtl){    double ViscDyng,ViscCing,Rog,ThermCondg,Prandtlg,ViscDynl,ViscCinl,Rol,ThermCondl,Prandtll;    TransProp_PT_g(P,T,ViscDyng,ViscCing,Rog,ThermCondg,Prandtlg);    TransProp_PT_l(P,T,ViscDynl,ViscCinl,Rol,ThermCondl,Prandtll);    ViscDyn=ViscDynl*(1-x)+ViscDyng*(x);    ViscCin=ViscCinl*(1-x)+ViscCing*(x);    Ro=Rol*(1-x)+Rog*(x);    ThermCond=ThermCondl*(1-x)+ThermCondg*(x);    Prandtl=Prandtll*(1-x)+Prandtlg*(x);}void FluidCore::TransProp_vT_a(const double &v,const double &T,double &ViscDyn,double &ViscCin,double &Ro,double &ThermCond,double &Prandtl){    double P = P_T_s(T);    double vl,vg;    v_PT(P,T,vl,vg);    if (v <= vl){        TransProp_vT_l(v,T,ViscDyn,ViscCin,Ro,ThermCond,Prandtl);    }    else if (v >= vg){        TransProp_vT_g(v,T,ViscDyn,ViscCin,Ro,ThermCond,Prandtl);    }    else{        double ViscDyng,ViscCing,Rog,ThermCondg,Prandtlg,ViscDynl,ViscCinl,Rol,ThermCondl,Prandtll;        TransProp_vT_g(v,T,ViscDyng,ViscCing,Rog,ThermCondg,Prandtlg);        TransProp_vT_l(v,T,ViscDynl,ViscCinl,Rol,ThermCondl,Prandtll);        double x=Mfraction(vl,vg,v);        ViscDyn=ViscDynl*(1-x)+ViscDyng*(x);        ViscCin=ViscCinl*(1-x)+ViscCing*(x);        Ro=Rol*(1-x)+Rog*(x);        ThermCond=ThermCondl*(1-x)+ThermCondg*(x);        Prandtl=Prandtll*(1-x)+Prandtlg*(x);}}void FluidCore::FlowProp_vT_a(const double &v,const double &T,double &CP,double &ViscDyn,double &Ro,double &ThermCond,double &Prandtl){    double P = P_T_s(T);    double vl,vg;    v_PT(P,T,vl,vg);    if (v <= vl){        FlowProp_vT_l(v,T,CP,ViscDyn,Ro,ThermCond,Prandtl);    }    else if (v >= vg){        FlowProp_vT_g(v,T,CP,ViscDyn,Ro,ThermCond,Prandtl);    }    else{        double ViscDyng,CPg,Rog,ThermCondg,Prandtlg,ViscDynl,CPl,Rol,ThermCondl,Prandtll;        FlowProp_vT_g(vg,T,CPg,ViscDyng,Rog,ThermCondg,Prandtlg);        FlowProp_vT_l(vl,T,CPl,ViscDynl,Rol,ThermCondl,Prandtll);        double x=Mfraction(vl,vg,v);        CP=CPg*(x)+CPl*(1-x);        ViscDyn=ViscDyng*(x)+ViscDynl*(1-x);        Ro=Rog*(x)+Rol*(1-x);        ThermCond=ThermCondg*(x)+ThermCondl*(1-x);        Prandtl=Prandtlg*(x)+Prandtll*(1-x);    }}//--------------------------------------------------------#pragma mark === SATURATION LINE FUNCTIONS ===//--------------------------------------------------------void FluidCore::Prop_T_s(const double &T,double &vl,double &vg,double &P,double &ul,double &ug,double &hl,double &hg,double &sl,double &sg){    if (T<=Tc)    {	P = P_T_s(T);        v_PT(P,T,vl,vg);        double Ptemp;        Prop_vT(vl,T,Ptemp,ul,hl,sl);        Prop_vT(vg,T,Ptemp,ug,hg,sg);    }    else{        cerr <<"Warning: call to Prop_T_s with T > Tc ...." << endl;    }}//------------------------------------------voidFluidCore::Prop_Tx_s(	const double &T,                         const double &x,                         double &v,                         double &P,                         double &u,                         double &h,                         double &s){	if (T<=Tc)    {	double vl,vg,ul,ug,hl,hg,sl,sg;        P = P_T_s(T);        v_PT(P,T,vl,vg);        double Ptemp;        Prop_vT(vl,T,Ptemp,ul,hl,sl);        Prop_vT(vg,T,Ptemp,ug,hg,sg);        v = vl + x*(vg-vl);        u = ul + x*(ug-ul);        h = hl + x*(hg-hl);        s = sl + x*(sg-sl);    }    else        cerr <<"Warning: call to Prop_Tx_s with T > Tc ...."<<endl;}double	FluidCore::v_PTx_a(const double &P, const double &T, const double &x){    double v;    if (x < 0){        cerr << "x not defined" << endl;        exit(1);    }    else if (x==1){        v=v_PT_g(P,T);    } else if (x==0){        v=v_PT_l(P,T);    }    else    {        double vg,vl;        vg=v_PT_g(P,T);        vl=v_PT_l(P,T);        v = vl + x*(vg-vl);    }    return v;}//------------------------------------------voidFluidCore::Prop_T_s(	const double &T,                        double &P,                        double &du,                        double &dh,                        double &ds){	double vl,vg,ul,ug,hl,hg,sl,sg;    Prop_T_s(T,vl,vg,P,ul,ug,hl,hg,sl,sg);    du = ug - ul;    dh = hg - hl;    ds = sg - sl;}//------------------------------------------voidFluidCore::Prop_P_s(	const double &P,                        double &vl,                        double &vg,                        double &T,                        double &ul,                        double &ug,                        double &hl,                        double &hg,                        double &sl,                        double &sg){	if (P<=Pc)    {	T = T_P_s(P);        v_PT(P,T,vl,vg);        double Ptemp;        Prop_vT(vl,T,Ptemp,ul,hl,sl);        Prop_vT(vg,T,Ptemp,ug,hg,sg);    }    else	cerr <<"Warning: call to Prop_P_s with P > Pc ...."<< endl;}//------------------------------------------voidFluidCore::Prop_P_s(	const double &P,                        double &T,                        double &du,                        double &dh,                        double &ds){	double vl,vg,ul,ug,hl,hg,sl,sg;    Prop_P_s(P,vl,vg,T,ul,ug,hl,hg,sl,sg);    du = ug - ul;    dh = hg - hl;    ds = sg - sl;}double FluidCore::v_PT_a(const double &P,const double &T) {    double v;    double Ps = P_T_s(T);    if (Ps>P)        v = v_PT_g(P,T);    else                    //TODO missing biphasic        v = v_PT_l(P,T);    return v;}double FluidCore::v_Tx_a(const double &T, const double &x) {    double v;    double P=P_T_s(T);    if (x==1)        v=v_PT_g(P,T);    else if (x==0)        v=v_PT_l(P,T);    else{        double vg,vl;        vg=v_PT_g(P,T);        vl=v_PT_l(P,T);        v = vl + x*(vg-vl);    }    return v;}//------------------------------------------// Surface tension correlation [N/m]// from "The properties of gases and liquids" of Reid & Prausnitz, Chap. 12.3doubleFluidCore::SurfaceTension(const double &T){	double Tbr = Tnb/Tc;    double q = 0.1196*(1.0+Tbr*ln(Pc/101.325)/(1.0-Tbr))-0.279;    return 1.0E-3*pow(Pc*1.0E-2,2.0/3.0)*pow(Tc,1.0/3.0)*q*pow(1.0-T/Tc,11.0/9.0);}//--------------------------------------------------------#pragma mark === DEW LINE FUNCTIONS  ===//--------------------------------------------------------doubleFluidCore::v_T_gs(const double &T){	return v_PT_g(P_T_s(T),T);}//--------------------------------------------------------#pragma mark === BUBBLE LINE FUNCTIONS  ===//--------------------------------------------------------doubleFluidCore::v_T_ls(const double &T){	return v_PT_l(P_T_s(T),T);}//------------------------------------------doubleFluidCore::T_v_ls(const double &v){	return 0.0;}//--------------------------------------------------------#pragma mark		=== LIQUID ZONE FUNCTIONS ===//--------------------------------------------------------doubleFluidCore::P_vT_l(const double &v,                  const double &T){	return P_vT(v,T);}//------------------------------------------voidFluidCore::CvCp_vT_l(	const double &v,                         const double &T,                         double &cv,                         double &cp){	CvCp_vT(v,T,cv,cp);}//------------------------------------------doubleFluidCore::T_vP_l(const double &v,                  const double &P){	return T_vP(v,P);}//------------------------------------------double FluidCore::v_PT_l(const double &P,const double &T){    double vl,vg;    v_PT(P,T,vl,vg);    return vl;}//------------------------------------------doubleFluidCore::T_vu_l(const double &v,                  const double &u){	return T_vu(v,u);}//------------------------------------------voidFluidCore::Prop_vu_l(	const double &v,                         const double &u,                         double &P,                         double &T,                         double &h,                         double &s){	double u1;    T = T_vu(v,u);    Prop_vT(v,T,P,u1,h,s);}//------------------------------------------doubleFluidCore::u_PT_l(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return u_vT(vl,T);}//------------------------------------------doubleFluidCore::h_PT_l(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return h_vPT(vl,P,T);}//------------------------------------------doubleFluidCore::s_PT_l(const double &P,                  const double &T){	double vl,vg;    v_PT(P,T,vl,vg);    return s_vT(vl,T);}//------------------------------------------doubleFluidCore::v_Ps_l(const double &P,                  const double &s){	return v_PT_l(P,T_Ps_l(P,s));}//------------------------------------------voidFluidCore::Prop_PT_l(	const double &P,                         const double &T,                         double &v,                         double &u,                         double &h,                         double &s){	double P1;    v = v_PT_l(P,T);    Prop_vT(v,T,P1,u,h,s);}//------------------------------------------doubleFluidCore::T_Ps_l(const double &P,                  const double &s){	double dT,T,To,f,fo,vl,vg;    // secant method:    // init point    T = T_P_s(P);    v_PT(P,T,vl,vg);    double sl = s_vT(vl,T);    f = sl-s;    dT = +0.0001;    do    {	// previous point record        fo = f;        To = T;        // next point calculation        T -= dT;        v_PT(P,T,vl,vg);        f =  s_vT(vl,T)-s;        // new delta        dT = (T-To)/(f-fo)*f;    } while (abs(dT)> T_precision);    T -= dT;    return T;}void FluidCore::CvCp_PT(const double &P,const double &T,double &cv,double &cp){    double v=v_PT_a(P,T);    CvCp_vT(v,T,cv,cp);}//------------------------------------------//ViscDyn in [Pa s],ViscCin in [m2/s],ThermCond in [W/(m K)]//from "The properties of gases and liquids" of Reid & Prausnitz, Chap. 9.4,9.6,10.5double FluidCore::getvc() {    return vc;}double FluidCore::getPc() {    return Pc;}double FluidCore::getTc() {    return Tc;}void FluidCore::set(const char *iFluidName,                  const double ivc,const double iPc,const double iTc,const double iTnb,const double iMw,const double iw,const double iDipM){    FluidName = (char*) iFluidName;    vc = ivc;    Pc = iPc;    Tc = iTc;    Tnb = iTnb;    Mw = iMw;    w = iw;    DipM = iDipM;    // reference state default initialisation    // liquid line    Tref = 273.15;	// [K]    href = 200.0E3;	// [J/kg]    sref = 1.0E3;	// [J/(kg K)]}void FluidCore::set_ref(const double iTref, const double ihref, const double isref){    Tref = iTref;    href = ihref;    sref = isref;}void fluid_define(FluidCore*&fluid,string &fluidname){    if(fluidname=="Water" || fluidname=="H2O" || fluidname=="Eau" || fluidname=="water"){        fluid= new MWater();        const char * fluidnamechar = "H2O";        fluid->FluidName = strdup(fluidnamechar);    }    else {        //if(mySet_PR.find(fluidname) != mySet_PR.end()){        unsigned int n = fluidname.length();        char fluidnamechar[n + 1];        strcpy(fluidnamechar, fluidname.c_str());        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        // Tests        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidnamechar);            fluid=new PRfluid(fluidnamechar,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                              PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                              PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11));    }}void fluid_define(FluidCore*&fluid, char* &fluidname){    if(strcmp(fluidname,"Water")==0 || strcmp(fluidname,"H2O")==0 || strcmp(fluidname,"Eau")==0 || strcmp(fluidname,"water")==0){        fluid= new MWater();}    else {        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidname);            fluid=new PRfluid(fluidname,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                              PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                              PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11));    }}void fluid_define(FluidCore*&fluid,string &fluidname, string & method){    if(method=="MWater"||method=="Water"||method=="water"||method=="Mwater"||method=="mwater") {        fluid = new MWater();    }    else if (method=="PengRobinson"||method=="PR"||method=="Pengrobinson"||method=="pengrobinson"){        //if(mySet_PR.find(fluidname) != mySet_PR.end()){        int n = fluidname.length();        char fluidnamechar[n + 1];        strcpy(fluidnamechar, fluidname.c_str());        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        // Tests        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidnamechar);        fluid=new PRfluid(fluidnamechar,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                          PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                          PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11));}    else if (method=="LeeKessler"||method=="LK"||method=="Leekessler"||method=="leekessler"){        //if(mySet_PR.find(fluidname) != mySet_PR.end()){        int n = fluidname.length();        char fluidnamechar[n + 1];        strcpy(fluidnamechar, fluidname.c_str());        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        // Tests        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidnamechar);        fluid=new LeeKessler(fluidnamechar,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                             PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                             PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11),PtrSeq->Get(12),PtrSeq->Get(13),PtrSeq->Get(14));}    else{cout<<"Not an implement method"<<endl;        cout<<"impement method: MWater - PengRobinson - CoolProp"<<endl;    }}void fluid_define(FluidCore*&fluid,char* &fluidnamechar, string & method){    if(method=="MWater"||"Water"||"water"||"Mwater"||"mwater") fluid= new MWater();    else if (method=="PengRobinson"||"PR"||"Pengrobinson"||"pengrobinson"){        //if(mySet_PR.find(fluidname) != mySet_PR.end()){        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        // Tests        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidnamechar);        fluid=new PRfluid(fluidnamechar,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                          PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                          PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11));}    else if (method=="LeeKessler"||"LK"||"Leekessler"||"leekessler"){        //if(mySet_PR.find(fluidname) != mySet_PR.end()){        const char sep = '\t';        const int nbTitleLines = 2; //nombre de lignes avec des titres        const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie        const char* file_in = "dataBase/DataFluids.txt";        TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);        InputFile.open();        // Tests        TSeqsArray Records(InputFile.nRecords());        InputFile.config(Tiofile::onrcds);        Records = *InputFile.GetRecords();        TSequence* PtrSeq = Get(Records, fluidnamechar);        fluid=new LeeKessler(fluidnamechar,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),                          PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),                          PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11),PtrSeq->Get(12),PtrSeq->Get(13),PtrSeq->Get(14));}    else {cout<<"Not an implement method"<<endl;        cout<<"Implement method: MWater - PengRobinson - LeeKessler- CoolProp"<<endl;    }}//-------------------------------------------------