//PengRobinson.cp#include "PengRobinson.h"#include <cmath>#include <set>using namespace std;//--------------------------------------------------------#pragma mark		=== TOOL FUNCTIONS ===//--------------------------------------------------------voidPRfluid::CubicRoots(const double& c0,                    const double& c1,                    const double& c2,                    const double& c3,                    double& r1,                    double& r2){    double a3 = c0 / c3;    double a2 = c1 / c3;    double a1 = c2 / c3;    double a1_2 = sqr(a1);    double q = (a1_2-3.0*a2)/9.0;    double r = (a1*(2.0*a1_2-9.0*a2)+27.0*a3)/54.0;    double q3r2 = pow(q,3.0) - sqr(r);    if (q3r2 > 0)    {	// 3 real solutions        double q2 = sqrt(q);        double phi = acos(r/pow(q,1.5));        double pi = 3.14159;// vl est donc assignee a r1 et vg a r2        r1 = -2.0 * q2 * cos(phi / 3.0)              - a1 / 3.0;        r2 = -2.0 * q2 * cos((phi + 2.0 * pi) / 3.0) - a1 / 3.0;        //r3 = -2.0 * q2 * cos((phi + 4.0 * pi) / 3.0) - a1 / 3.0;    }    else    {	// 1 real solution        double temp = pow(sqrt(-q3r2)+fabs(r),1.0/3.0);        r2 = r1 = -fabs(r)/r*(temp+q/temp)-a1/3.0;    }}//--------------------------------------------------------voidPRfluid::QuadraticRoots(const double& cc,                        const double& bb,                        const double& aa,                        double& r1,                        double& r2){	// precise quadratic solution formulation    // ax^2+bx+c=0    double q = -0.5*(bb+sign(bb)*sqrt(sqr(bb)-4.0*aa*cc));    r1 = q/aa;    r2 = cc/q;}//--------------------------------------------------------#pragma mark		=== INIT FUNCTIONS ===//--------------------------------------------------------PRfluid::PRfluid(	char *iFluidName,                     const double &ivc,                     const double &iPc,                     const double &iTc,                     const double &iTnb,                     const double &iMw,                     const double &iw,                     const double &iDipM,                     const double &ic0,                     const double &ic1,                     const double &ic2,                     const double &ic3,                     const double &ic4){	FluidName = strdup(iFluidName);    vc = ivc;    Pc = iPc;    Tc = iTc;    Tnb = iTnb;    Mw = iMw;    w = iw;    DipM = iDipM;    // cpo coefficients    c0 = ic0;    c1 = ic1;    c2 = ic2;    c3 = ic3;    c4 = ic4;    // reference state default initialisation    // liquid line    Tref = 273.15;	// [K]    href = 200.0E3;	// [J/kg]    sref = 1.0E3;	// [J/(kg K)]    PRfluid::init();}/*PRfluid::PRfluid(const char *iFluidName){    // Lecture du fichier fluide    const char sep = '\t';    const char* file_in = "fluids/LKDataFluidsNEW5.txt";    // Nombre de lignes / Colones de titres    const int nbTitleLines = 2; //nombre de lignes avec des titres    const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie    // Debut du traitement    TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);    InputFile.open();    int nbRecords = InputFile.nRecords();    TSeqsArray Records(InputFile.nRecords());// création du tableau VIDE avec le même nombre de Lignes que de nombre de records de InputFile    InputFile.config(Tiofile::onrcds); //on configure le TSeqsArray en mode Records (ie ligne de résultats et pas colonnes)    Records = *InputFile.GetRecords(); //on ajoute les valeurs des Records de l'InputFile    //Initialisation du fluide de travail    char* FluidName = (char*)iFluidName;    TSequence* PtrSeq = Get(Records, FluidName);    PRfluid(FluidName,PtrSeq->Get(0),PtrSeq->Get(1),PtrSeq->Get(2),PtrSeq->Get(3),PtrSeq->Get(4),PtrSeq->Get(5),PtrSeq->Get(6),PtrSeq->Get(7),PtrSeq->Get(8),PtrSeq->Get(9),PtrSeq->Get(10),PtrSeq->Get(11));}*///-------------------------------------------------voidPRfluid::set (	char *iFluidName,                  const double &ivc,                  const double &iPc,                  const double &iTc,                  const double &iTnb,                  const double &iMw,                  const double &iw,                  const double &iDipM){   FluidName = strdup(iFluidName);    vc = ivc;    Pc = iPc;    Tc = iTc;    Tnb = iTnb;    Mw = iMw;    w = iw;    DipM = iDipM;    // reference state default initialisation    // liquid line    Tref = 273.15;	// [K]    href = 200.0E3;	// [J/kg]    sref = 1.0E3;	// [J/(kg K)]}//-------------------------------------------------voidPRfluid::set(	    const double &ic0,                     const double &ic1,                     const double &ic2,                     const double &ic3,                     const double &ic4){	c0 = ic0;    c1 = ic1;    c2 = ic2;    c3 = ic3;    c4 = ic4;}//-------------------------------------------------voidPRfluid::init(){    k = 0.0;    r = R*1.0E3/Mw;//aa, bb, mm sont definis par le modele de Peng Robinson    aa = 0.45724*sqr(r*Tc)/Pc;    bb = 0.07780*r*Tc/Pc;    mm = 0.37464+w*(1.54226-w*0.26992);    vc = v_PT_g(Pc,Tc);    Zc = Pc*vc/r/Tc;// set FluidAprox class    Set(Pc,Tc,Zc,w);    double Ps = P_T_s(Tref);    h_cst = href-h_PT_l(Ps,Tref);    s_cst = sref-s_PT_l(Ps,Tref);    double P;    Prop_vT(vc,Tc,P,uc,hc,sc);}//-------------------------------------------------voidPRfluid::set(	const double &iTref,                 const double &ihref,                 const double &isref){	Tref = iTref;    href = ihref;    sref = isref;}//--------------------------------------------------------#pragma mark		=== BASE FUNCTIONS ===//--------------------------------------------------------doublePRfluid::Alpha(const double &T){	return (1.0+mm*(1.0-sqrt(T/Tc)))*(1.0+mm*(1.0-sqrt(T/Tc)));}//------------------------------------------doublePRfluid::aT(const double &T){	return aa*(1.0+mm*(1.0-sqrt(T/Tc)))*(1.0+mm*(1.0-sqrt(T/Tc)));}//------------------------------------------// dAdT=�a(T)/�TdoublePRfluid::dAdT(const double &T){	return aa*mm/Tc*(mm-(1.0+mm)*sqrt(Tc/T));}//------------------------------------------// dAdT2=�2a(T)/�T2doublePRfluid::dAdT2(const double &T){	return aa*mm*(1.0+mm)/(2.0*T*sqrt(T*Tc));}//------------------------------------------// lnb=�1/(v*(v+b)+b*(v-b))*dvdoublePRfluid::lnb(const double &v){	return log((v+bb*(1.0-sqrt2))/(v+bb*(1.0+sqrt2)))/(2*sqrt2*bb);}//------------------------------------------void PRfluid::CvCp_T_o(	const double &T,                           double &cvo,                           double &cpo){	cpo = c0+T*(c1+T*(c2+T*c3))+c4/sqr(T);    cvo = cpo-r;}//------------------------------------------doublePRfluid::CvDep_T(	const double &v,                     const double &T){	return -T*dAdT2(T)*lnb(v);}//------------------------------------------voidPRfluid::CvCp_vT(	const double &v,                     const double &T,                     double &cv,                     double &cp){	double cvo,cpo;    CvCp_T_o(T,cvo,cpo);    double cvr=CvDep_T(v,T);    cv = cvo + cvr;    double dPdv,dPdT;    dPvdPT_vT(v,T,dPdv,dPdT);    cp = cv-T*sqrt(dPdT)/dPdv;}//------------------------------------------doublePRfluid::h_T_o(const double &T){	return T*(c0+T*(0.5*c1+T*(c2/3.0+0.25*c3*T)))-c4/T + h_cst;}//------------------------------------------doublePRfluid::s_T_o(const double &T){	return T*(c1+T*(0.5*c2+T*c3/3.0))+c0*ln(T)-0.5*c4/sqr(T) + s_cst;}//------------------------------------------voidPRfluid::IdealState(const double &T,                    double &cpo,                    double &cvo,                    double &ho,                    double &so){	CvCp_T_o(T,cvo,cpo);    ho = h_T_o(T);    so = s_T_o(T);}//------------------------------------------voidPRfluid::dPvdPT_vT(	const double &v,                       const double &T,                       double &dPdv,                       double &dPdT){	double v_bb = v-bb;    double vb = v*(v+bb)+bb*v_bb;    dPdT = r/v_bb         - dAdT(T)/vb;    dPdv = -r*T/sqrt(v_bb) + aT(T)*2.0*(v+bb)/sqrt(vb);}//------------------------------------------voidPRfluid::AvBpGt_vT(	const double &v,                       const double &T,                       double &Av,                       double &Bp,                       double &Gt){	double dPdv,dPdT;    dPvdPT_vT(v,T,dPdv,dPdT);    double P = P_vT(v,T);    Av = P/T/dPdT;    Gt = -P/v/dPdv;    Bp = Av/Gt;}//------------------------------------------doublePRfluid::LnPhi_avPT(const double &a_T,                    const double &v,                    const double &P,                    const double &T){   return (P*v+a_T*lnb(v))/(r*T)-(log(P*(v-bb))+1.0);}//--------------------------------------------------------#pragma mark		=== v P T FUNCTIONS ===//--------------------------------------------------------doublePRfluid::P_vT(	const double &v,                  const double &T){	double v_bb = v-bb;    return r*T/v_bb-aT(T)/(v*(v+bb)+bb*v_bb);}//------------------------------------------doublePRfluid::P_avT(	const double &a_T,                   const double &v,                   const double &T){	double v_bb = v-bb;    return r*T/v_bb-a_T/(v*(v+bb)+bb*v_bb);}//------------------------------------------doublePRfluid::T_vP(	const double &v,                  const double &P){    if (P < Pc) {        //temperature correction for v<vg        double Tsat, vl, vg;        T_P_s(P, Tsat, vl, vg);        if (v >= vl && v <= vg)   // biphasic --> return T=Tsat            return Tsat;    }    double v_bb = v-bb;    double v2b  = v*(v+bb)+bb*v_bb;    // compact quadratic solution formulation    // ax^2+bx+c=0 -> x1 = ((b/a/2)^2-c/a)^0.5-b/a/2    double f_a = r*v2b/v_bb-aa*sqr(mm)/Tc;    double f_ba2 = 2.0*aa/sqrt(Tc)*mm*(1.0+mm)/f_a/2.0;    double f_ca =-(aa*sqr(1.0+mm)+P*v2b)/f_a;    return sqr(sqrt(sqr(f_ba2)-f_ca)-f_ba2);}//------------------------------------------voidPRfluid::v0_T(	const double &T,                  double &vl,                  double &vg){	// return v=f(P=0,T)    double aux = aT(T)/(r*T);    QuadraticRoots(bb*(aux-bb),2.0*bb-aux,1.0,vg,vl);}//------------------------------------------voidPRfluid::v_PT(	const double &P,                  const double &T,                  double &vl,                  double &vg,                  double &a_T){    a_T = aT(T);    double a0,a1,a2,a3;//a3*v^3 + a2*v^2 + a1*v + a0 = 0// Les constantes ci-dessous sont d�finies par le mod�le de PengRobinson    a3 = -P;    a2 = r*T - P*bb;    a1 = bb*(2.0*r*T + 3.0*P*bb) - a_T;    a0 = bb*(a_T - bb*(r*T + P*bb));    CubicRoots (a0,a1,a2,a3,vl,vg);}//------------------------------------------voidPRfluid::v_PT(	const double &P,                  const double &T,                  double &vl,                  double &vg){	double a_T;    v_PT(P,T,vl,vg,a_T);}//------------------------------------------doublePRfluid::u_avT(	const double &a_T,                   const double &v,                   const double &T){	return h_T_o(T)-r*T-(T*dAdT(T)-a_T)*lnb(v);}//------------------------------------------doublePRfluid::u_vT(const double &v,              const double &T){	return h_T_o(T)-r*T-(T*dAdT(T)-aT(T))*lnb(v);}//------------------------------------------doublePRfluid::h_avT(const double &a_T,               const double &v,               const double &T){	return P_avT(a_T,v,T)*v+u_avT(a_T,v,T);}//------------------------------------------doublePRfluid::h_vT(const double &v,              const double &T){	double a_T=aT(T);    return P_avT(a_T,v,T)*v+u_avT(a_T,v,T);}//------------------------------------------doublePRfluid::h_avPT(const double &a_T,                const double &v,                const double &P,                const double &T){	return P*v+u_avT(a_T,v,T);}//------------------------------------------doublePRfluid::h_vPT(	const double &v,                   const double &P,                   const double &T){	return P*v+u_vT(v,T);}//------------------------------------------doublePRfluid::s_vT(	const double &v,                  const double &T){	return	s_T_o(T)+r*ln((v-bb)/(r*T))-dAdT(T)*lnb(v);}//------------------------------------------voidPRfluid::Prop_vT(	const double &v,                     const double &T,                     double &P,                     double &u,                     double &h,                     double &s){    double vl=0,vg=0;               // cornelia.blanke: added biphasic state    if (T<Tc) {        double Ps = P_T_s(T);        v_PT(Ps, T, vl, vg);    }    if (v > vl && v < vg){        double x = Mfraction(vl,vg,v);        double vtemp;        Prop_Tx_s(T, x,vtemp,P,u,h,s);    }    else {        double v_bb = v - bb;        double a_T = aT(T);        P = r * T / v_bb - a_T / (v * (v + bb) + bb * v_bb);        double cpo, cvo, ho, so;        IdealState(T, cpo, cvo, ho, so);        double lnfb = lnb(v);        double dadT = dAdT(T);        u = ho - r * T - (T * dadT - a_T) * lnfb;        h = u + v * P;        s = so + r * ln(v_bb / (r * T)) - dadT * lnfb;    }}voidPRfluid::TransProp_PT_l(const double &P,                        const double &T,                        double &ViscDyn,                        double &ViscCin,                        double &Ro,                        double &ThermCond,                        double &Prandtl){	const int k = 0;    double v, cv, cp;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y;    v = v_PT_l(P, T);    CvCp_vT_l(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[�P]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7*ViscStar*36.344*sqrt(Mw*Tc)/pow(Vcu,0.6666666);    ViscCin = ViscDyn / Ro;//--- Thermal Conduction ---//eq. (10-9.5)    ThermCond = (1.11/sqrt(Mw))*(3.0+20.0*pow(1.0-Tr,0.66666666))/(3.0+20.0*pow(1.0-Tnb/Tc,0.66666666));    Prandtl = cp * ViscDyn / ThermCond;}void PRfluid::TransProp_vT_l(const double &v,const double &T,double &ViscDyn,double &ViscCin,double &Ro,double &ThermCond,double &Prandtl){    const int k = 0;    double cv, cp;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y;    CvCp_vT_l(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[�P]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7*ViscStar*36.344*sqrt(Mw*Tc)/pow(Vcu,0.6666666);    ViscCin = ViscDyn / Ro;//--- Thermal Conduction ---//eq. (10-9.5)    ThermCond = (1.11/sqrt(Mw))*(3.0+20.0*pow(1.0-Tr,0.66666666))/(3.0+20.0*pow(1.0-Tnb/Tc,0.66666666));    Prandtl = cp * ViscDyn / ThermCond;}void PRfluid::FlowProp_vT_l(const double &v,const double &T,double &cp,double &ViscDyn,double &Ro,double &ThermCond,double &Prandtl){    const int k = 0;    double cv;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y;    CvCp_vT_l(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[�P]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7*ViscStar*36.344*sqrt(Mw*Tc)/pow(Vcu,0.6666666);//--- Thermal Conduction ---//eq. (10-9.5)    ThermCond = (1.11/sqrt(Mw))*(3.0+20.0*pow(1.0-Tr,0.66666666))/(3.0+20.0*pow(1.0-Tnb/Tc,0.66666666));    Prandtl = cp * ViscDyn / ThermCond;}void PRfluid::FlowProp_vT_g(const double &v,const double &T,double &cp,double &ViscDyn,double &Ro,double &ThermCond,double &Prandtl){    const int k = 0;    double cv;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double Visc0, ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y, Psi, Ag, Bg, Z, q;    CvCp_vT_g(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[microP]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7 * ViscStar * 36.344 * sqrt(Mw * Tc) / pow(Vcu, 2.0 / 3.0);//*** Thermal conductivity ***//eq. (9-4.9)    Visc0 = 40.785 * Fc * sqrt(Mw * T) / pow(Vcu,0.6666666) / OmegaV; //[�P]//eq. (10-3.17)    Ag = cv * MWu / R - 1.5;    Bg = 0.7862 + w * (-0.7109 + 1.3168 * w);    Z = 2.0 + 10.5 * sqr(Tr);    Psi = 1.0 + Ag * ((0.215 + 0.28288 * Ag - 1.061 * Bg + 0.26665 * Z) / (0.6366 + Bg * Z + 1.061 * Ag * Bg));    G2 = (B(1) / y * (1.0 - exp(-B(4) * y)) + B(2) * G1 * exp(B(5) * y) + B(3) * G1) / (B(1) * B(4) + B(2) + B(3));    q = 3.586E-3 * sqrt(Tc / MWu) / pow(Vcu, 2.0 / 3.0);    ThermCond = 31.2 * Visc0 * 1E-7 * Psi / MWu * (1.0 / G2 + B(6) * y) + q * B(7) * sqr(y) * sqrt(Tr) * G2;    Prandtl = cp * ViscDyn / ThermCond;}void PRfluid::TransProp_vT_g ( const double &v,const double &T,double &ViscDyn,double &ViscCin,double &Ro,double &ThermCond,double &Prandtl){const int k = 0;    double cv, cp;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double Visc0, ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y, Psi, Ag, Bg, Z, q;    CvCp_vT_g(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[microP]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7 * ViscStar * 36.344 * sqrt(Mw * Tc) / pow(Vcu, 2.0 / 3.0);    ViscCin = ViscDyn / Ro;//*** Thermal conductivity ***//eq. (9-4.9)    Visc0 = 40.785 * Fc * sqrt(Mw * T) / pow(Vcu,0.6666666) / OmegaV; //[�P]//eq. (10-3.17)    Ag = cv * MWu / R - 1.5;    Bg = 0.7862 + w * (-0.7109 + 1.3168 * w);    Z = 2.0 + 10.5 * sqr(Tr);    Psi = 1.0 + Ag * ((0.215 + 0.28288 * Ag - 1.061 * Bg + 0.26665 * Z) / (0.6366 + Bg * Z + 1.061 * Ag * Bg));    G2 = (B(1) / y * (1.0 - exp(-B(4) * y)) + B(2) * G1 * exp(B(5) * y) + B(3) * G1) / (B(1) * B(4) + B(2) + B(3));    q = 3.586E-3 * sqrt(Tc / MWu) / pow(Vcu, 2.0 / 3.0);    ThermCond = 31.2 * Visc0 * 1E-7 * Psi / MWu * (1.0 / G2 + B(6) * y) + q * B(7) * sqr(y) * sqrt(Tr) * G2;    Prandtl = cp * ViscDyn / ThermCond;}voidPRfluid::TransProp_PT_g ( const double &P,                          const double &T,                          double &ViscDyn,                          double &ViscCin,                          double &Ro,                          double &ThermCond,                          double &Prandtl){	const int k = 0;    double v, cv, cp;    double Tr, Ror, Mur, Tstar, Vcu, MWu;    double Visc0, ViscStar, Visc2Star, OmegaV, Fc;    double G1, G2, y, Psi, Ag, Bg, Z, q;    v = v_PT_g(P,T);    CvCp_vT_g(v,T,cv,cp);//*** viscosities ***    Ro = 1.0 / v;    Ror = vc * Ro;    MWu = Mw * 1E-3;//[kg/mol]    Vcu = 1E3 * vc * Mw;//[cm3/mole]    Tr = T / Tc;    Tstar = 1.2593 * Tr;//eq. (9-4.3)    OmegaV = 1.16145 * pow(Tstar, -0.14874) + 0.52487 * exp(-0.7732 * Tstar) + 2.16178 * exp(-2.43787 * Tstar);//eq. (9-4.11)    Mur = 131.3 * DipM / sqrt(Vcu * Tc);//eq. (9-4.10)    Fc = 1.0 - 0.2756 * w + 0.059035 * sqr(Mur) + k;//eq. (9-6.18)    y = vc * Ro / 6.0;//eq. (9-6.19)    G1 = (1.0 - y / 2.0) / pow(1.0 - y, 3);//eq. (9-6.20)    G2 = (E(1) / y * (1.0 - exp(-E(4) * y)) + E(2) * G1 * exp(E(5) * y) + E(3) * G1) / (E(1) * E(4) + E(2) + E(3));//eq. (9-6.21)    Visc2Star = E(7) * sqr(y) * G2 * exp(E(8) + E(9) / Tstar + E(10) / sqr(Tstar));//eq. (9-6.17)    ViscStar = sqrt(Tstar) / OmegaV * (Fc * (1.0 / G2 + E(6) * y)) + Visc2Star; //[microP]//eq. (9-6.16) Chung et al. method    ViscDyn = 1E-7 * ViscStar * 36.344 * sqrt(Mw * Tc) / pow(Vcu, 2.0 / 3.0);    ViscCin = ViscDyn / Ro;//*** Thermal conductivity ***//eq. (9-4.9)    Visc0 = 40.785 * Fc * sqrt(Mw * T) / pow(Vcu,0.6666666) / OmegaV; //[�P]//eq. (10-3.17)    Ag = cv * MWu / R - 1.5;    Bg = 0.7862 + w * (-0.7109 + 1.3168 * w);    Z = 2.0 + 10.5 * sqr(Tr);    Psi = 1.0 + Ag * ((0.215 + 0.28288 * Ag - 1.061 * Bg + 0.26665 * Z) / (0.6366 + Bg * Z + 1.061 * Ag * Bg));    G2 = (B(1) / y * (1.0 - exp(-B(4) * y)) + B(2) * G1 * exp(B(5) * y) + B(3) * G1) / (B(1) * B(4) + B(2) + B(3));    q = 3.586E-3 * sqrt(Tc / MWu) / pow(Vcu, 2.0 / 3.0);    ThermCond = 31.2 * Visc0 * 1E-7 * Psi / MWu * (1.0 / G2 + B(6) * y) + q * B(7) * sqr(y) * sqrt(Tr) * G2;    Prandtl = cp * ViscDyn / ThermCond;}//--------------------------------------------------------#pragma mark === SATURATION LINE FUNCTIONS ===//--------------------------------------------------------double PRfluid::T_P_s(const double &P){    double T, vl, vg;    T_P_s(P, T, vl, vg);    return T;}void PRfluid::T_P_s(const double &P, double &T, double &vl, double &vg){    if (P<Pc)    {        double To,Fro;        // secant method:        // init point        T = Ti_P_s(P);        v_PT(P,T,vl,vg);        double a_T = aT(T);        double Fr = LnPhi_avPT(a_T,vl,P,T)/LnPhi_avPT(a_T,vg,P,T)-1.0;        // init delta        double dT = 0.1;        do        {	// previous point record            Fro = Fr;            To = T;            // next point calculation            T -= dT;            v_PT(P,T,vl,vg);            a_T = aT(T);            Fr = LnPhi_avPT(a_T,vl,P,T)/LnPhi_avPT(a_T,vg,P,T)-1.0;            // new delta            dT = (T-To)/(Fr-Fro)*Fr;        } while (fabs(dT)> T_precision);        T -= dT;    }    else {        T = Tc;        cerr << "vl, vg not defined for P > Pc" << endl;    }}//------------------------------------------double PRfluid::P_T_s(const double &T){    double P, vl, vg;    P_T_s(T, P, vl, vg);    return P;}void PRfluid::P_T_s(const double &T, double &P, double &vl, double &vg){    if (T<Tc)    {	double a_T = aT(T);        double Po,Fro;        // secant method:        // init point        // on choisi une pression initiale        P = Pi_T_s(T);        //cout<<P<<endl;        // on r�soud l'�quation d'�tat afin de trouver les racines (vl et vg dans notre cas)        v_PT(P,T,vl,vg);        // calcul de la fugacit�        double Fr = LnPhi_avPT(a_T,vl,P,T)/LnPhi_avPT(a_T,vg,P,T)-1.0;        // init delta        double dP = 1.0E2;        do        {	// previous point record            Fro = Fr;            Po = P;            // next point calculation            P -= dP;            v_PT(P,T,vl,vg);            Fr = LnPhi_avPT(a_T,vl,P,T)-LnPhi_avPT(a_T,vg,P,T);            //cout<<LnPhi_avPT(a_T,vg,P,T)<<endl;            // new delta            dP = (P-Po)/(Fr-Fro)*Fr; //*Fr;            //cout<<P << " " << Fr <<endl;        } while (fabs(dP)>= P_precision);        P -= dP;    }    else {        P = Pc;        cerr << "vl, vg not defined for T > Tc" << endl;    }}PRfluid::PRfluid(const char* iFluidName) {    const char sep = '\t';    const int nbTitleLines = 2; //nombre de lignes avec des titres    const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie    const char* file_in = "dataBase/DataFluids.txt";    // Debut du traitement    //cout << "Test Input Ouput file : " << file_in << endl << endl;    TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);    InputFile.open();    // Tests    TOutputFile OutputFile((char*)"iofdata.out");    OutputFile.open();    int nbRecords = InputFile.nRecords();    TSeqsArray Records(InputFile.nRecords());    InputFile.config(Tiofile::onrcds);    Records = *InputFile.GetRecords();    FluidName = (char*)iFluidName;    TSequence* PtrSeq = Get(Records, FluidName);    vc = PtrSeq->Get(0);    Pc = PtrSeq->Get(1);    Tc = PtrSeq->Get(2);    Tnb = PtrSeq->Get(3);    Mw = PtrSeq->Get(4);    w = PtrSeq->Get(5);    DipM = PtrSeq->Get(6);    // cpo coefficients    c0 = PtrSeq->Get(7);    c1 = PtrSeq->Get(8);    c2 = PtrSeq->Get(9);    c3 = PtrSeq->Get(10);    //c4 = PtrSeq->Get(11); //pas de 5eme coefficent cp dans le fichier d'entrée    // reference state default initialisation    // liquid line    Tref = 273.15;	// [K]    href = 200.0E3;	// [J/kg]    sref = 1.0E3;	// [J/(kg K)]    PRfluid::init();}PRfluid::PRfluid(const char* iFluidName,const char* file_in ) {    const char sep = '\t';    const int nbTitleLines = 2; //nombre de lignes avec des titres    const int nbTitleColumns = 1; //nombre de colonnes avec des titres ie sans chiffre ie    //  const char* file_in = "fluids/LKDataFluidsNEW5.txt";    // Debut du traitement    //cout << "Test Input Ouput file : " << file_in << endl << endl;    TInputFile  InputFile((char*)file_in, nbTitleLines, nbTitleColumns, sep);    //InputFile.open();    // Tests    TOutputFile OutputFile((char*)"iofdata.out");    OutputFile.open();    int nbRecords = InputFile.nRecords();    TSeqsArray Records(InputFile.nRecords());    InputFile.config(Tiofile::onrcds);    Records = *InputFile.GetRecords();    FluidName = (char*)iFluidName;    TSequence* PtrSeq = Get(Records, FluidName);    vc = PtrSeq->Get(0);    Pc = PtrSeq->Get(1);    Tc = PtrSeq->Get(2);    Tnb = PtrSeq->Get(3);    Mw = PtrSeq->Get(4);    w = PtrSeq->Get(5);    DipM = PtrSeq->Get(6);    // cpo coefficients    c0 = PtrSeq->Get(7);    c1 = PtrSeq->Get(8);    c2 = PtrSeq->Get(9);    c3 = PtrSeq->Get(10);    //c4 = PtrSeq->Get(11); //pas de 5eme coefficent cp dans le fichier d'entrée    // reference state default initialisation    // liquid line    Tref = 273.15;	// [K]    href = 200.0E3;	// [J/kg]    sref = 1.0E3;	// [J/(kg K)]    PRfluid::init();}