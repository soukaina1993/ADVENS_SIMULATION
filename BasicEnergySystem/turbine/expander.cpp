/*******************************************************************************Expander.cppC++ functions for the performance calculations of volumetric turbine Copyright © 2000 LENI-DGM-EPFL.  All rights reserved.$Id: Expander.cpp,v 1.0 2000/03/14 17:10:00 Malick Kane Exp $*******************************************************************************/#include "Expander.h"#define Pi 3.1415;#define until(exp) while(!(exp))/****************************************************************************/ gao 	 * TExpander::ga 	   = new gao ("expdata.txt", "exprslts.txt");/*//--------------------------------------------------------------TExpander::TExpander (const expander tp, const TTurbine::SpeedMode sp){    type 	(tp);    speed	(sp);    //optimizer 	(theGA)     pdata	= new ExpDataRcd;    flag		= true;         bcga		= TExpander::ga;	//default ga      ivbles	= new TSequence (TExpander::ga->data->genome());    idxtp	= (unsigned int) tp;    idxsp	= (unsigned int) sp;        init ();}*///--------------------------------------------------------------TExpander::TExpander (LeeKessler* &fluidin1,const TExpander::expander tp	,                      const TTurbine::SpeedMode sp	):fluidinside(fluidin1){    type 	(tp);    speed	(sp);    bcga		= TExpander::ga;	//default ga      ivbles	= new TSequence (TExpander::ga->data->genome());    idxtp	= (unsigned int) tp;    idxsp	= (unsigned int) sp;        init ();}TExpander::TExpander (LeeKessler::LKFluidRec * pflddata,                      const TExpander::expander tp,const TTurbine::SpeedMode sp	){    type 	(tp);    speed	(sp);    bcga		= TExpander::ga;	//default ga    ivbles	= new TSequence (TExpander::ga->data->genome());    idxtp	= (unsigned int) tp;    idxsp	= (unsigned int) sp;    init ();}TExpander::TExpander(const char *iExpanderName,const TExpander::expander tp,const TTurbine::SpeedMode sp){    type 	(tp);    speed	(sp);    expParams expParams("expparam.txt") ;    expParams.RegisterParams(*this, iExpanderName);}void  TExpander::optimize  (TTurbine::Criteria ob, gao::type GA) {    obj = ob;    if (!(obj==TTurbine::COST))        bcga->maximize(*this, GA);    else        bcga->minimize(*this, GA);}//--------------------------------------------------------------gao * TExpander::optimizer (gao & theGA){    bcga=&theGA;    if (!(bcga==TExpander::ga)){    	delete ivbles;    	ivbles	= new TSequence (bcga->data->genome());    }    return bcga;}//--------------------------------------------------------------TExpander::TExpander (const TExpander & orig){    fluidinside	= orig.fluidinside;    flag		= true;     ivbles	= new TSequence (*orig.ivbles);      this->copy(orig);}//--------------------------------------------------------------void TExpander::copy(const TExpander & orig){       // *pdata	= *orig.pdata; // change to copy all data       spd   	= orig.spd;       exptp 	= orig.exptp;       ivbles->copy(*orig.ivbles);        bcga  	= orig.bcga;     }//------------------------------------------void TExpander::init (){    expregister();    // InitMacroExpanderLib();   //calling pascal functions //TODO doesn exist!     variable  ();     //performance();  }void TExpander::SetFluid(LeeKessler::LKFluidRec & fld){    LeeKessler(fld.fluidName);}//------------------------------------------void TExpander::expregister (){   switch (exptp){      case TExpander::ANYTYPE:   {      	params->DefaultParams(*this);      	break;      }      case TExpander::TRANE:	{      	params->RegisterParams(*this, "Trane");      	break;      }      case TExpander::MANEUROPE:	{         params->RegisterParams(*this, "Man");         break;      }      case TExpander::COPELAND:	{         params->RegisterParams(*this, "Cop");         break;      }      case TExpander::ATLAS:	{         params->RegisterParams(*this, "Atlas");         break;      }        case TExpander::HITACHI:	{         params->RegisterParams(*this, "Hitachi");         break;      }               }}//------------------------------------------void TExpander::expselector (){   switch (idxtp)    {	case 0:	{type  (TExpander::ANYTYPE);	break;}	case 1:	{type  (TExpander::TRANE);		break;}	case 2:	{type  (TExpander::MANEUROPE);	break;}	case 3:	{type  (TExpander::COPELAND);	break;}	case 4:	{type  (TExpander::ATLAS);		break;}	case 5:	{type  (TExpander::HITACHI);	break;}   }   //nSpeed (idxsp);   switch (idxsp)    {	case 0:	{speed (TExpander::VARIABLE); 	break;}	case 1:	{speed (TExpander::FIXED);		break;}   }   }//------------------------------------------TSequence & TExpander::variable    () {      /*   Pin 	= ivbles->Get(TExpander::ga->data->idRecord("Pin"))  ;   Tin 	= ivbles->Get(TExpander::ga->data->idRecord("Tin"))  ;   Xin 	= ivbles->Get(TExpander::ga->data->idRecord("Xin"))  ;   Pout 	= ivbles->Get(TExpander::ga->data->idRecord("Pout")) ;   Mflow = ivbles->Get(TExpander::ga->data->idRecord("Mflow"));   Nrot 	= ivbles->Get(TExpander::ga->data->idRecord("Nrot")) ;   */   flow->StateIn->P 	= ivbles->Get(0);    flow->StateIn->T 	= ivbles->Get(1);    flow->StateIn->x 	= ivbles->Get(2);    flow->StateOut->P	= ivbles->Get(3);    *flow->Massflow = ivbles->Get(4);    InitMassFlow=ivbles->Get(4);   Nrot 	= ivbles->Get(5);         if (bcga!=TExpander::ga){    	idxtp = (unsigned int)ivbles->Get(6);        idxsp = (unsigned int)ivbles->Get(7);   	expselector();   }      return * ivbles;}//------------------------------------------TSequence & TExpander::variable(TSequence& seq) {   ivbles->copy (seq);   return  variable();}     //------------------------------------------BasicES &TExpander::performance (){   if (!fluidinside==NULL){	//InitExpanderData();       // InitExpanderData(Pin,Tin, Xin, Pout, Mflow, Nrot); // TODO verifier si c'est utile!	  	   /*switch (spd) {		case TTurbine::VARIABLE:	MacroExpanderM (*pdata);		case TTurbine::FIXED:	MacroExpanderN (*pdata);	   }*/	   	if (!exptp==TExpander::ANYTYPE) {	   switch (spd) {	   case 0:           MacroExpanderM ();	   case 1:	MacroExpanderN ();	   }	}else 	  SimpleExpander ();   }else cout<<"The working fluid is not attribued !!"<<endl;   return *this;		}//------------------------------------------//Retourne la puissance Žlectrique de la turbine//------------------------------------------ floatTExpander::power (TSequence& seq) {	variable(seq);	performance ();	return seq.Value = ElecPower;}//------------------------------------------//Retourne la rendement isentrope global de la turbine//------------------------------------------ floatTExpander::efficiency (TSequence& seq) {	variable(seq);	performance ();	return seq.Value = EtaG*100;}//------------------------------------------//Retourne la rendement isentrope global de la turbine//------------------------------------------ floatTExpander::cost (TSequence& seq) {	variable(seq);	performance ();	return seq.Value = Cost;}//------------------------------------------//Select the appropiate objective function//------------------------------------------ float TExpander::objective (TSequence& seq){	   float sc=0.0;   switch (obj) {	case 0:	{sc = power	(seq); break;}	case 1:	{sc = efficiency 	(seq); break;}	case 2:	{sc = cost	(seq); break;}   }	   return sc;		}//------------------------------------------void TExpander::display (){      cout<<"Electric power                 [kW] :       "<<ElecPower/1E3<<endl;   cout<<"Rotor speed                 [t/min] :       "<<Nrot*60<<endl;   cout<<"Mass flow rate               [kg/s] :       "<<*flow->Massflow<<endl;   cout<<"Mass flow rate extracted        [%] :       "<<alphaH*100<<endl;   cout<<"Inlet volumetric flow rate   [m3/h] :       "<<Mvol*3600<<endl;   cout<<"Pressure ratio                  [-] :       "<<1/PR<<endl;   cout<<"Superheating                 [degC] :       "<<dTsur<<endl;   cout<<"Number of unit                  [-] :       "<<NTins<<endl;   cout<<"Filling factor                  [-] :       "<<CR * 100<<endl;   cout<<"Installed volume rate           [-] :       "<<VRi<<endl;   cout<<"Suction volume                [cm3] :       "<<Vsuction  * 1E6<<endl;   cout<<"Global isentrope efficiency     [%] :       "<<EtaG*100<<endl;   cout<<"Expander cost                 [CHF] :       "<<Cost<<endl;   cout<<endl;         cout<<"Suction line "<<endl;   cout<<"Inlet Pressure                [bar] :       "<<flow->StateIn->P/1E5<<endl;   cout<<"Inlet Temperature            [degC] :       "<<flow->StateIn->T-273.15<<endl;   cout<<"Inlet Title                     [-] :       "<<flow->StateIn->x<<endl;   cout<<"Fluid density                   [-] :       "<<pstateIn->Ro<<endl;   cout<<"Fluid viscosity             [mm2/s] :       "<<pstateIn->ViscCin * 1E6<<endl;   cout<<endl;       cout<<"Discharge line "<<endl;   cout<<"Outlet Pressure               [bar] :       "<<flow->StateOut->P/1E5<<endl;   cout<<"Outlet Temperature           [degC] :       "<<flow->StateOut->T-273.15<<endl;   cout<<"Outlet Title                    [-] :       "<<flow->StateOut->x<<endl;   cout<<endl;           }/****************************************************************************/ void copy (TExpander & dest, TExpander& src ){   dest.Length		=	src.Length;   dest.Width		=	src.Width;   dest.Height		=	src.Height;   dest.Weight		=	src.Weight;   dest.Cfric1		=	src.Cfric1;   dest.Cfric2		=	src.Cfric2;   dest.NrotNom		=	src.NrotNom;      dest.InitMassFlow	=	src.InitMassFlow;   dest.InitNrot		=	src.InitNrot;   dest.EtaElec		=	src.EtaElec;   dest.EtaEMnom		=	src.EtaEMnom;      dest.Aadm		=	src.Aadm;   dest.Diameter		=	src.Diameter;   dest.Vsuction		=	src.Vsuction;   dest.VRi		=	src.VRi;   dest.PRi		=	src.PRi;      dest.flow->StateIn->P		=	src.flow->StateIn->P;   dest.flow->StateIn->T		=	src.flow->StateIn->T;   dest.flow->StateIn->x		=	src.flow->StateIn->x;   dest.flow->StateOut->P		=	src.flow->StateOut->P;   *dest.flow->Massflow	=	*src.flow->Massflow;   dest.Nrot		=	src.Nrot;      dest.flow->StateOut->T		=	src.flow->StateOut->T;   dest.flow->StateOut->x		=	src.flow->StateOut->x;   dest.ElecPower		=	src.ElecPower;   dest.EtaG		=	src.EtaG;   dest.PR		=	src.PR;   dest.CR		=	src.CR;   dest.flow->Power	=	src.flow->Power;   dest.MechPower		=	src.MechPower;   dest.InternalHeatLoss	=	src.InternalHeatLoss;   dest.LeakageMassFlow	=	src.LeakageMassFlow;   dest.TurbineMassFlow	=	src.TurbineMassFlow;   dest.EtaEM		=	src.EtaEM;      dest.EtaMech		=	src.EtaMech;   dest.Load		=	src.Load;   dest.ElecPowerMax		=	src.ElecPowerMax;   dest.Mvol		=	src.Mvol;   dest.Cone		=	src.Cone;   dest.mhu		=	src.mhu;      dest.EtaP		=	src.EtaP;   dest.ZetaQ		=	src.ZetaQ;   dest.Eta			=	src.Eta;   dest.Kapa		=	src.Kapa;   dest.Emdh		=	src.Emdh;   dest.Ework		=	src.Ework;   dest.Epoly		=	src.Epoly;   dest.Np		=	src.Np;      dest.Cost		=	src.Cost;}/****************************************************************************/void expParams::DefaultParams (TExpander & expdata){   expdata.Vsuction	=	72.5E-6;   expdata.NTins		=	1;   expdata.NTfon		=	1;   expdata.Nvar		=	1;   expdata.VRi		=	2.43;   expdata.CR		=	1.05;   expdata.ElecPowerMax	=	8E3;   expdata.EtaTs		=	0.87;   expdata.EtaElec	=	0.90;   expdata.EtaMech	=	0.95;   expdata.Diameter	=	18E-3;   expdata.Length		=	10E-3;   expdata.Width		=	25E-6;   expdata.Height		=	100E-3;   expdata.Weight		=	70;   expdata.InitNrot	=	50; //50   expdata.NrotNom	=	50; //50   expdata.Nrot		=	52; //52   expdata.Cfric1		=	20;   expdata.Cfric2		=	400;   expdata.InitMassFlow	=	0.4;   expdata.alphaH		=	0.0;   expdata.dTsur		=	10;} //------------------------------------------------- void expParams::RegisterParams (TExpander & expdata, const char * expname){   expdata.Vsuction	=	Vs	(expname);     expdata.VRi		=	VRi	(expname);     expdata.ElecPowerMax	=	Power	(expname);     expdata.EtaTs		=	EtaTs	(expname);     expdata.EtaElec	=	EtaElec	(expname);     expdata.Diameter	=	Dadm	(expname);     expdata.Length		=	Length	(expname);     expdata.Width		=	Width	(expname);     expdata.Height		=	Height	(expname);   expdata.Weight		=	Weight	(expname);   expdata.NrotNom	=	NrotNom	(expname);   expdata.Cfric1		=	Cfric1	(expname);   expdata.Cfric2		=	Cfric2	(expname);}//--------------------------- Fonction PASCAL -----------------------------------///void TExpander::SimpleExpander   	(){    ThermoPhysicCalculation(pstateIn,flow->StateIn);    VolumetricExpander   	();    ExpanderCapacity 	(*flow->Massflow);    ElecPower    = ElecPower * *flow->Massflow;    flow->Power  = flow->Power * *flow->Massflow;    MechPower    = MechPower * *flow->Massflow;    InternalHeatLoss = InternalHeatLoss * *flow->Massflow;};void TExpander::InitExpanderData        (float iPsup,float iTsup,float  ixsup,float iPinf, float iMflow,float  iNrot){    flow->StateIn->P = iPsup;    flow->StateIn->T =iTsup;    flow->StateIn->x = ixsup;    flow->StateOut->P = iPinf;    *flow->Massflow = iMflow;    Nrot = iNrot;}void TExpander::MacroExpanderM      	(){    double vl, Pl, Tl, Sv;    TThermoState downstateIsen, Inlet, EndExp, Outlet;    double Workadm,Workcdet,Workodet,Workdis;    double VsuctFon, DiamFon, AadmFon;// ----------------------------------------- //    Aadm 	= Section(Diameter); // TODO find the right value    VsuctFon	= Vsuction * NTfon/ NTins;    DiamFon	= Diameter * NTfon/ NTins;    AadmFon	= Aadm * NTfon/ NTins;    // Test : Valid input ? //    if (flow->StateIn->P <= flow->StateOut->P){        // CSIPfailure = MacroExpanderMFailed;        // exit (MacroExpanderM);        cout<<"flow->StateIn->P <= flow->StateOut->P    ",flow->StateIn->P/1E5,' --> ',flow->StateOut->P/1E5;    }// Init of downstate thermo data //    downstate.P = flow->StateOut->P;// Calculation of upstate thermo data //    // with upstate do    upstate.P = flow->StateIn->P;    upstate.T = flow->StateIn->T;    upstate.x = flow->StateIn->x;    fluidinside->Prop_PTx_bg(upstate.P, upstate.T, upstate.v, upstate.h, upstate.s, upstate.x);    flow->StateIn->T = upstate.T;    flow->StateIn->x = upstate.x;// Calculation of sonic data //    // with upstate do    fluidinside->Sonic_PT_g(upstate.P, upstate.T, vl, Pl,Tl, Sv);    if( *flow->Massflow >Sv / vl * AadmFon){        cout<<"Input *flow->Massflow > Sonic MassFlow --> not possible !!!";        cout<<('P bar : ',upstate.P/1E5);        cout<<('T degC : ',upstate.T-273.15);        cout<<('m kg/s : ',*flow->Massflow);        cout<<('Sv m/s : ',Sv);        cout<<('Fluid : ',fluidinside->FluidName);        cout<<"convergency error MacroExpander"<<endl;        exit(EXIT_FAILURE);    }// Calculation of Inlet thermo data //    //with Inlet do  //  Inlet.P =flow->StateIn->P;    Inlet.P =       racine_suction(Pl, flow->StateIn->P, 1000);    if ((flow->StateIn->P<Inlet.P)or(Inlet.P<Pl)){        cout<<"error MacroExpander M"<<endl;        cout<<('Pinlet problem ! ',Inlet.P/1E5);        exit(EXIT_FAILURE);    }    Inlet.h = upstate.h;    fluidinside->Prop_Ph_bg(Inlet.P, Inlet.h, Inlet.v, Inlet.T, Inlet.s, Inlet.x);// Calculation of MassFlow /(    LeakageMassFlow = leakage(Inlet.P - downstate.P, 1 / Inlet.v, 20E-6);    TurbineMassFlow = *flow->Massflow - LeakageMassFlow;    Nrot = TurbineMassFlow * Inlet.v / VsuctFon;    CR = *flow->Massflow / (VsuctFon * Nrot / upstate.v);    Mvol = upstate.v * *flow->Massflow;// Calculation of the adiabatic, without leakage turbine Volumetric expansion //    // Feeding work //    Workadm=Inlet.v*Inlet.P*TurbineMassFlow;    // Closed expansion work //    // with EndExp do    EndExp.v = Inlet.v * VRi;    fluidinside->Prop_vs_bg(EndExp.v, Inlet.s,EndExp. P, EndExp.T, EndExp.h, EndExp.x);    EndExp.h = Inlet.h - EtaTs * (Inlet.h - EndExp.h);    fluidinside->Prop_vh_bg(EndExp.v, EndExp.h, EndExp.P, EndExp.T, EndExp.s,EndExp.x);    Workcdet=TurbineMassFlow*(Inlet.h-EndExp.h+EndExp.v*EndExp.P-Inlet.v*Inlet.P);    // Discharge expansion work //    Workodet=0.0;    // Discharge  work //    Workdis=-VsuctFon* VRi*downstate.P*Nrot;    // Total  work //    flow->Power=(Workadm+Workcdet+Workodet+Workdis);// Calculation of the Outlet //    // with Outlet do    Outlet.h = upstate.h-flow->Power/TurbineMassFlow;    Outlet.P = downstate.P;    fluidinside->Prop_Ph_bg(Outlet.P, Outlet.h, Outlet.v, Outlet.T, Outlet.s, Outlet.x);// Various calculation //    MechPower = flow->Power - mechanicalLoss(Nrot);    ElecPower = EtaElec * MechPower;    InternalHeatLoss = flow->Power - ElecPower;// Calculation of the downstate   //    // with downstate do    // Flow mixture  turbine/leakage //    downstate.h = (TurbineMassFlow * Outlet.h + LeakageMassFlow * Inlet.h) / *flow->Massflow;    // Internal heat transfert effect //    downstate.h = downstate.h + InternalHeatLoss / *flow->Massflow;    fluidinside->Prop_Ph_bg(downstate.P, downstate.h, downstate.v, downstate.T, downstate.s,downstate. x);    flow->StateOut->T = downstate.T;    flow->StateOut->x = downstate.x;// Calculation of the overall adiabatic efficiency //    downstateIsen.P = downstate.P;    downstateIsen.s = upstate.s;    fluidinside->Prop_Ps_bg(downstateIsen.P,downstateIsen. s,downstateIsen. v,downstateIsen. T,downstateIsen. h,downstateIsen. x);    EtaMech = MechPower / flow->Power;    EtaEM   = ElecPower / flow->Power;    EtaG    = ElecPower / (*flow->Massflow * (upstate.h - downstateIsen.h));// Calculation of pressure ratio //    PR = downstate.P / upstate.P;    Load= ElecPower / ElecPowerMax;}void TExpander::MacroExpanderN      	(){    double MassFlowi;    int i;    InitNrot = Nrot;    MassFlowi = InitMassFlow;    do{    i = 0;       if(i>200){           cout<<"error MacroExpanderN"<<endl;           exit(EXIT_FAILURE);       }    *flow->Massflow = MassFlowi;    MacroExpanderM();    MassFlowi = MassFlowi * InitNrot / Nrot;}    while (abs(Nrot - InitNrot) * 60 > 1);    InitMassFlow = *flow->Massflow;};//-------------------------------------------------void TExpander::VolumetricExpander() {    TThermoState Inter, Outlet, OutletS;    double Workadm, Workcdet, Workodet, Workdis;    upstate.P = flow->StateIn->P;    upstate.T = flow->StateIn->T;    upstate.x = flow->StateIn->x;    fluidinside->Prop_PTx_bg(upstate.P, upstate.T,upstate.v,upstate.h,upstate.s,upstate.x);    flow->StateIn->T = upstate.T;    flow->StateIn->x = upstate.x;    downstate.P = flow->StateOut->P;// Volumetric expansion}    Inter.v = upstate.v * VRi;    //fluidinside->Prop_vs_bg(Inter.v, upstate.s, Inter.P, Inter.T, Inter.h, Inter.x);    fluidinside->Prop_vs_g(Inter.v, upstate.s, Inter.P, Inter.T, Inter.h);    Inter.h = upstate.h - EtaTs * (upstate.h - Inter.h);    fluidinside->Prop_vh_bg(Inter.v, Inter.h, Inter.P, Inter.T, Inter.s, Inter.x);    PRi = upstate.P / Inter.P;    Mvol = upstate.v;    Vsuction = Mvol / (CR * Nrot);    Workadm = upstate.v * upstate.P / CR;    Workcdet = (upstate.h - Inter.h + Inter.v * Inter.P - upstate.v * upstate.P) / CR;    // Discharge expansion work}    Workodet = 0.0;    // Discharge  work}    Workdis = -Vsuction * VRi * downstate.P * Nrot;    // Total  work    flow->Power = (Workadm + Workcdet + Workodet + Workdis);    Outlet.h = Outlet.h - flow->Power * CR; //TODO verifier cette formule    Outlet.P = downstate.P;    fluidinside->Prop_Ph_bg(Outlet.P, Outlet.h, Outlet.v, Outlet.T, Outlet.s, Outlet.x);    // Various calculation}    MechPower = EtaMech * flow->Power;    ElecPower = EtaElec * MechPower;    InternalHeatLoss = flow->Power - ElecPower;// Calculation of the downstate  }// Flow mixture  turbine/leakage}    downstate.h = (Outlet.h / CR + (1 - 1 / CR) * upstate.h);// Internal heat transfert effect}    downstate.h = downstate.h + InternalHeatLoss;//Prop_Ph_bg(p, h, v, T, s, x);    fluidinside->Prop_Ph_bg(downstate.P, downstate.h, downstate.v, downstate.T, downstate.s, downstate.x);    downstate.x=fluidinside->x_Ph(downstate.P,downstate.h);    flow->StateOut->T = downstate.T;    flow->StateOut->x = downstate.x;    ThermoPhysicCalculation(pstateOut,flow->StateOut);    OutletS.P = downstate.P;    OutletS.s = upstate.s;    fluidinside->Prop_Ps_bg(OutletS.P, OutletS.s, OutletS.v, OutletS.T, OutletS.h, OutletS.x);    EtaG = ElecPower / (upstate.h - OutletS.h);    EtaEM = EtaElec * EtaMech;// Calculation of pressure ratio}    PR = downstate.P / upstate.P;}void TExpander::ExpanderCapacity(double Mflow){                double TR,Vsi, DNi;        *flow->Massflow   = Mflow;        Mvol = Mvol * *flow->Massflow;        Vsuction = Vsuction * *flow->Massflow;        //Diameter = Diametre (Vsuction, NrotNom);        //Aadm 	= Section(Diameter);        Vsi	= Vsuction / NTins;        DNi	= Diameter / NTins;        Diameter = NTins * Diameter_cal (Vsi, NrotNom);        Aadm 	= NTins * Section  (DNi);    Cone = Vsuction / (8314 / fluidinside->Mw);        // facteurs polytropiques}        TR  = downstate.T / upstate.T;        PR  = downstate.P / upstate.P;        Np  = 1 / (1 - ln(TR) / ln(PR));}double TExpander::Section(double diam){    double a=0.25*Pi;            return  sqr(diam)*a;}double TExpander::Diameter_cal(double Vs, double Nr){    double a=4/Nr *Vs *Pi;    return sqrt(a/Cin);}double TExpander::moodyDiag(double moodyFactor){    double root= sqrt(moodyFactor);    return 2 * ln(Re * root) / ln(10) - 0.8 - 1 / root;}double TExpander::mechanicalLoss(double ANrot, double NrotNom, double Cfric1, double Cfric2, double Nr){    return Cfric1 *(ANrot/NrotNom) + Cfric2 * sqrt(ANrot/NrotNom);}double TExpander::mechanicalLoss(double ANrot){    return Cfric1 *(ANrot/NrotNom) + Cfric2 * sqrt(ANrot/NrotNom);}double TExpander::leakage(double deltaP, double ro, double viscDyn){    //we need theses var from out of scope    double speed, section, hydrodiam,moodyFactor,massFlow, massFlowi;    int i=0;    massFlow = *flow->Massflow *0.05;    section = Width* Height;    hydrodiam = 2*section / (Width + Height);    do{        massFlowi= massFlow;        speed = massFlow / section / ro;        Re = speed * hydrodiam * ro/viscDyn;        // TODO find what happens with this function        moodyFactor = racine_moodyDiag(0.01, 1, 1e-3);        massFlow = section * sqrt(2*ro*deltaP*hydrodiam / Length /moodyFactor);        //max iteration break        if (i> 200){            cout<<"error Leakage"<<endl;            exit(EXIT_FAILURE);        }        i++;    }until((massFlowi - massFlow)/massFlow < 0.01);    return massFlow;}double TExpander::racine_moodyDiag(double borneInf, double borneSup, double ecart){    const int maxIteration = 100;    double xl, xh, swap, fl, dx, del, f, fh, rtf =0.0;    //Calcul the Moodydiag    fl = moodyDiag(borneInf);    fh = moodyDiag(borneSup);    if (fl< 0.0){        xl = borneInf;        xh = borneSup;    }    else{        xl = borneSup;        xh = borneInf;        //swap fl and fh        swap = fl;        fl = fh;        fh = swap;    }    dx = xh -xl;    for (int j=0; j < maxIteration; j++){        rtf = xl + dx * fl /(fl -fh);        if(rtf<0)            cout<<"error rtf<0"<<endl;        f= moodyDiag(rtf);        if (f <0.0){            del = xl -rtf;            xl = rtf;            fl = f;        }        else{            del = xh -rtf;            xh = rtf;            fh = f;        }        dx = xh -xl;        if((abs(del)< ecart) || f==0.0){            j=maxIteration;        }    }    if(!((abs(del)< ecart) || f==0.0)){        //exit(MacroExpanderM);        cout << "Pause in routine RTSLP moody"<<endl;        cout << "Maximum number of iteration exceeded"<<endl;        cout<<"error racine_moodyDiag"<<endl;        exit(EXIT_FAILURE);    }    return rtf;}double TExpander::racine_suction(double borneInf, double borneSup, double ecart){    const int maxIteration = 100;    double xl, xh, swap, fl, dx, del, f, fh, rtf =0.0;    //Calcul the Moodydiag    fl = suction(borneInf);    fh = suction(borneSup);    if (fl< 0.0){        xl = borneInf;        xh = borneSup;    }    else{        xl = borneSup;        xh = borneInf;        //swap fl and fh        swap = fl;        fl = fh;        fh = swap;    }    dx = xh -xl;    for (int j=0; j < maxIteration; j++){        rtf = xl + dx * fl /(fl -fh);        f= suction(rtf);        if (f <0.0){            del = xl -rtf;            xl = rtf;            fl = f;        }        else{            del = xh -rtf;            xh = rtf;            fh = f;        }        dx = xh -xl;        if((abs(del)< ecart) || f==0.0){           j=maxIteration;        }    }    if(!((abs(del)< ecart) || f==0.0)){        cout << "Pause in routine RTSLP "<<endl;        cout << "Maximum number of iteration exceeded"<<endl;        exit(EXIT_FAILURE);    }    return rtf;}double TExpander::suction(double Pc) {    double vc, tc, hc, cc, xc;    fluidinside->Prop_Ps_bg(Pc, upstate.s, upstate.v, upstate.T, hc, upstate.u);    cc = sqrt(2 * abs(upstate.h - hc));    //return cc * AdamFon / vc - totalMassFlow;    double adamFon = Aadm * NTfon / NTins;// TODO verifier    return cc * adamFon / vc - *flow->Massflow;}void TExpander::ThermoPhysicCalculation(TPhysicState *pstate, TState *State) {    pstate->P=State->P;    pstate->T=State->T;    pstate->x=State->x;    if (pstate->x > 0)        fluidinside->TransProp_PT_g(pstate->P, pstate->T, pstate->ViscDyn, pstate->ViscCin, pstate->Ro, pstate->ThermCond,pstate->Prandtl);    else        fluidinside->TransProp_PT_l(pstate->P, pstate->T, pstate->ViscDyn, pstate->ViscCin, pstate->Ro, pstate->ThermCond, pstate->Prandtl);}void TExpander::InitExpanderParameters(){// - Leakage path --//    InitMassFlow= 0.4;    InitNrot 	= 50;    NTins 	= 1;		//Nombre de turbine install?    NTfon 	= 1;		//Nombre de turbine en fonctionnement    Nvar 	= 1;		//Vitesse variable (Nvar=0) ou constante (Nvar=1)    mhu = 0.99;   // Diameter = NTins * Diametre (Vsuction / NTins, NrotNom);    Aadm 	= NTins * Section(Diameter / NTins);}